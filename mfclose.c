#include	<StdLib.h>#include	"mstdio.h"#include 	"macio.h"#include "mmalloc.h"longmfflush(	register M_FILE *iop){	register char 	*base ;	register int	n_chars ;	/* Make sure this isn't readonly	 */	if ((iop->_flag & (_MIOREAD|_MIORW)) == _MIOREAD) {		iop->_flag |= _MIOERR;		return(EOF);	}	/* See if there is anything to flush.	 */	if ( iop->_flag & _MIOWRT && (base=iop->_base) != NULL )		n_chars = iop->_ptr - base ;	else 		n_chars = 0 ;	/* Reset the M_FILE info to indicate that the buffers	 * have been flushed.  For {line,un}buffered, update, or	 * System V append mode files _cnt is set to 0 so that	 * the next putc() / getc() will call _flsbuf() / _filbuf().	 * In update mode the write flag is turned off to indicate	 * that there are no characters in the file to be written.	 */	iop->_ptr = iop->_base;	iop->_cnt = ( iop->_flag & ( _MIOLBF | _MIONBF | _MIORW | _MIOAPPEND ) ) 	          ? 0 : iop->_bufsiz ;	if (iop->_flag & _MIORW) 		iop->_flag &= ~_MIOWRT ;	/* Now flush the buffer if there is actually anything to write.	 * This is done after all the flags are reset, so that an	 * interrupted write won't cause an infinite loop, if the signal	 * handler tries to flush/close this file again.  This can happen	 * when a pclose() is done as a result of a SIGPIPE signal, without	 * the calling program setting the action for SIGPIPE to SIG_IGN.	 */	if (n_chars > 0) {		if (mwrite(mfileno(iop),base,n_chars) != n_chars){			iop->_flag |= _MIOERR;				return(EOF) ;		}	}		return(0);}longmfclose(	register M_FILE *iop){	register int r;	if(!iop)		return EOF;	r = EOF;	if (iop->_flag&(_MIOREAD|_MIOWRT|_MIORW) && (iop->_flag&_MIOSTRG)==0) {		/* Flush the file if it is open for output, then close it		 * and free any buffers allocated by stdio.		 */		if (iop->_flag & (_MIOWRT|_MIORW))			r = mfflush(iop);		else			r = 0;		if (_mclose(mfileno(iop)) < 0)			r = EOF;		if (iop->_flag&_MIOMYBUF)			mfree(iop->_base);	}	iop->_cnt = 0;	iop->_base = (char *)NULL;	iop->_ptr = (char *)NULL;	iop->_bufsiz = 0;	iop->_flag = 0;	iop->_file = 0;	return(r);}