#include	"mstdio.h"#include 	"macio.h"#include	<Unix_errno.h>long_mfilbuf(	register M_FILE	*iop){	register char	*base;	register int	chars_to_read;	register int	sysV_append_mode = (iop->_flag & _MIOAPPEND);	char		smallbuf;	if (iop->_flag & _MIORW) {		/* If the file has been written, flush it so that		 * System V style append mode will work correctly.		 */		if (sysV_append_mode && (iop->_flag & _MIOWRT))			mfflush(iop);		/* Indicate that we have done a read.		 */		iop->_flag &= ~_MIOWRT;		iop->_flag |= _MIOREAD;	}	/* Make sure that this is readable	 */	if ((iop->_flag&(_MIOSTRG|_MIOWRT|_MIOREAD)) != _MIOREAD) {		iop->_flag |= _MIOERR ;		errno = EBADF ;		return(EOF);	}	if (sysV_append_mode) {		/* If the file is opened for APPEND, the number of characters		 * in the buffer is stored as negative number in the _cnt		 * field.  This forces the calls to getc() to call _filbuf()		 * everytime.  Since getc() decrements the _cnt field, we		 * have to increment by two to see if there are still 		 * characters in the buffer.  If _cnt is then <= 0 we can		 * simply return the next character from the buffer and the		 * absolute value of _cnt is the number of characters left.		 */		iop->_cnt += 2;		if (iop->_cnt <= 0)			return((int)((unsigned char)*iop->_ptr++));	}	/* Flush stdout and stderr if necessary.	 */		/* Get a buffer if we don't have one.  Note that unbuffered	 * files use a temporary buffer allocated on the stack in 	 * this routine.	 */	for (;;) {		base = iop->_base;		if (base != NULL) {			chars_to_read = iop->_bufsiz;			break;		}		if (iop->_flag & _MIONBF) {			base = &smallbuf;			chars_to_read = 1;			break;		}		/* Try to get a buffer for fully or line buffered files. If		 * this routine doesn't succeed, it sets the file to 		 * unbuffered.		 */		_mgetstdiobuf(iop);	}		/* Reset the pointer to the base of the buffer.	 */	iop->_ptr = base ;	/* Now finally do the read.	 */	iop->_cnt = mread(mfileno(iop), base, chars_to_read);	if (--iop->_cnt < 0) {		if (iop->_cnt == -1) {			iop->_flag |= _MIOEOF;			if (iop->_flag & _MIORW)				iop->_flag &= ~_MIOREAD;		} else			iop->_flag |= _MIOERR;		/*		 * Indicate that the buffer is empty, so that a write after		 * reading EOF in update mode will work correctly.		 */		iop->_cnt = 0;		return(EOF);	} else if (sysV_append_mode) 		/* The number of characters in the buffer is stored as a		 * negative number.  This forces getc() to call _filbuf()		 * everytime, and just as importantly will cause putc()		 * to call _flsbuf().  This is necesary to make append mode		 * work.		 */		iop->_cnt = -iop->_cnt;	return((int)((unsigned char)*iop->_ptr++));}