#include	<String.h>#include	"mstdio.h"/* In the regular ULTRIX environment the numeric arguments are unsigned * values and the number of bytes to write are the product of those * arguments (ie. size and count). */#define BYTES_TO_WRITE(x,y) ((x) * (y))longmfwrite(	register char	*ptr,	unsigned long	size,	unsigned long	count,	register M_FILE	*iop){	register int s;	s = BYTES_TO_WRITE(size,count);	if (s == 0) return(0);	if (iop->_flag & _MIOLBF)		while (s > 0) {			if (--iop->_cnt > -iop->_bufsiz && *ptr != '\n')				*iop->_ptr++ = *ptr++;			else if (_mflsbuf(*(unsigned char *)ptr++, iop) == EOF)				break;			s--;		}	else {		int unbuffered;		char temp_buf[MBUFSIZ];		/* If the file is unbuffered, then use the temporary buffer, 		 * and make the file look like it is buffered.  This prevents		 * a write(2) system call from being done for every character.		 */		unbuffered = iop->_flag & _MIONBF;		if (unbuffered) {			iop->_flag &= ~_MIONBF;			iop->_ptr = iop->_base = temp_buf;			iop->_bufsiz = MBUFSIZ;			iop->_cnt = 0;		}		while (s > 0) {			if (iop->_cnt < s) {				if (iop->_cnt > 0) {					memcpy(iop->_ptr, ptr,  iop->_cnt);					ptr += iop->_cnt;					iop->_ptr += iop->_cnt;					s -= iop->_cnt;				}				if (_mflsbuf(*(unsigned char *)ptr++, iop) == EOF)					break;				s--;			}			if (iop->_cnt >= s) {				memcpy(iop->_ptr, ptr,  s);				iop->_ptr += s;				iop->_cnt -= s;				s = 0;			}		}		/* If the file is unbuffered, then flush it and check the 		 * status to make sure that anything in the temporary buffer		 * is written, then make it into an unbuffered file again.		 */		if (unbuffered) {			int status = mfflush(iop);			iop->_flag |= _MIONBF;			iop->_base = NULL;			iop->_bufsiz = 0;			iop->_cnt = 0;			if (status == EOF)				return(0) ;		}	}	if (s == 0)		return(count) ;	else		return (count - ((s + size - 1) / size));}