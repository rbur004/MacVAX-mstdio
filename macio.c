/*System includes*/#include	<types.h>#include 	<quickdraw.h>#include 	<packages.h>#include 	<Files.h>#include 	<StandardFile.h>#include 	<errors.h>#include	<resources.h>#include 	"mstdio.h"#include	<OSutils.h>//#include	<OSEvents.h> //Now in Events.h#include	<Events.h>#include	<memory.h>#include	<Strings.h>#include	<String.h>#include	<StdLib.h>#define __MACIO_C#include "macio.h"#include "mstdio.h"#include "aprintf.h"#include "mmalloc.h"/*Open an existing file via the standard file box*/MFILE *mopen(	char *ftype	/* types of files to display*/){struct Point 			dlgOrigin;			/* dialogbox top left corner*/static SFReply			theReply;			/* Data returned from dialogbox*/short 					num;				/* number of file types*/SFTypeList 				types;				/* file types*/char					*p;//OSErr	error;			dlgOrigin.h = DLGLEFT;			dlgOrigin.v = DLGTOP;						for (p = (char *) types, num = 0; *ftype && num < 16; num++ )				*p++ = *ftype++;			num /= 4;			if(num == 0)				num = -1;	/*display any type*///			SFGetFile(dlgOrigin,(void *)"", (FileFilterProcPtr) 0, num, types, (DlgHookProcPtr)0, &theReply);			SFGetFile(dlgOrigin,(void *)"",  0, num, types, 0, &theReply);			if(theReply.good)			{	p2cstr(theReply.fName);							return( mopen_na((char *)&theReply.fName,theReply.vRefNum) ) ;			}			return((MFILE *)0);}MFILE *mopen_na(	char *name,		short vrefnum){MFILE 	*fp;				/*Mac file descriptor*/OSErr	error;						if((fp = (MFILE *)mcalloc(sizeof(MFILE), 1)) == 0)			{				aprintf("MOPEN_NA:\nUnable to obtain enough memory to open file %s",name);				return (MFILE *) 0;			}			if((error = fsopen(name,vrefnum,&fp->fd)) == noErr)			{					fp->rfd = openrfperm(name,vrefnum,fsRdWrPerm);				if(ResError() != noErr)				{					fp->rfd = 0;				}				current_vrefnum = vrefnum;				fp->vrefnum = vrefnum;				strcpy(fp->name, name);				return(fp);			}			else			{	/*aprintf("Open failed: %s,%x",name,vrefnum);*/				ap_error("mopen_na",error);				mfree(fp);				return((MFILE *)0);			}}/*create a file by asking user with SFBOX*/MFILE *mcreat(	char *prompt,	/* prompt string*/	char *filename,	/*filename */	OSType creator,	OSType type){struct Point 	dlgOrigin;			/* dialogbox top left corner*/static SFReply	theReply;			/* Data returned from dialogbox*/MFILE 			*fp;					/*Mac file descriptor*/OSErr			error;			dlgOrigin.h = DLGLEFT;			dlgOrigin.v = DLGTOP;									if((fp = (MFILE *)mcalloc(sizeof(MFILE), 1)) == 0)			{				aprintf("mcreat:\nUnable to obtain enough memory to create file %s",filename);				return (MFILE *) 0;			}//			sfputfile(&dlgOrigin, prompt, filename, (DlgHookProcPtr)0, &theReply);			sfputfile(&dlgOrigin, prompt, filename, 0, &theReply);			if(theReply.good)			{					p2cstr(theReply.fName);				if((error = create( (char *)&theReply.fName,theReply.vRefNum,creator,type)) != noErr && error != dupFNErr)				{						ap_error("mcreat: create",error);						mfree(fp);						return((MFILE *)0);				}					if((error = fsopen((char *)&theReply.fName,theReply.vRefNum,&fp->fd)) == noErr)				{					 	fp->vrefnum = theReply.vRefNum;					current_vrefnum = theReply.vRefNum;					strcpy(fp->name, (char *)&theReply.fName);					fp->rfd = 0;					if((error = SetEOF(fp->fd,(long)0)) == noErr)					{						return(fp);					}					FSClose(fp->fd);					}				ap_error("mcreat",error);				mfree(fp);				return((MFILE *)0);			}			mfree(fp);			return((MFILE *)0);}long mwrite(	short fd,	char *buff,	long count){OSErr			error;	if((error = FSWrite(fd, &count, buff)) == noErr)		return(count);	ap_error("mwrite",error);	return(-1);}long mread(	short fd,	char *buff,	long count){OSErr			error;	if((error = FSRead(fd, &count, buff)) == noErr || error == eofErr)		return(count);	ap_error("mread",error);	return(-1);	}long mclose(	MFILE *fp){short 	vrefnum;OSErr	error;	if(fp == 0)	{		aprintf("mclose: Null file pointer");		return(-1);	}	if((error = GetVRefNum(fp->fd, &vrefnum)) != noErr)	{	ap_error("mclose: GetVRefNum", error);		return(-1);	}		if((error = FSClose(fp->fd)) != noErr)	{	ap_error("mclose: FSClose",error);		return(-1);	}	if(fp->rfd != 0)	{	CloseResFile(fp->rfd);		if((error = ResError()) != noErr)		{	ap_error("mclose: CloseResFile",error);			return(-1);		}	}	mfree(fp);	if((error = flushvol(0L,vrefnum)) != noErr)	{	ap_error("mclose: flushvol",error);		return(-1);	}	return(0);}	#define BUFFSIZE 1024char empty[BUFFSIZE];long mlseek(	short fd,	int 	offset,	short	whence){OSErr			error;long			current_eof;long 			absolute_fp;long 			more_space;long			count = BUFFSIZE;	if(whence == 0) 	{			whence = fsFromStart; /*from beginning of file*/		absolute_fp = offset;	}	else if(whence == 1) 	{	whence = fsFromMark; /*from current mark*/		if((error = GetFPos(fd, &absolute_fp)) !=  noErr)		{			ap_error("mlseek: GetFPos",error);			return -1;		}		absolute_fp += offset;	}	else /*from end of file*/	{			if((error = GetEOF(fd,&absolute_fp)) !=  noErr)		{			ap_error("mlseek: GetEOF 1",error);			return -1;		}		absolute_fp += offset;	}	if((error = SetFPos(fd, (short) whence,  offset )) == noErr)		return absolute_fp;	if(error == eofErr)	{		if((error = GetEOF(fd,&current_eof)) !=  noErr)		{				ap_error("mlseek: GetEOF 2",error);			return -1;		}		else		more_space = absolute_fp - current_eof + 1;		while(more_space > 0)		{	count = BUFFSIZE;			if((error = FSWrite(fd, &count, empty )) !=  noErr)			{					ap_error("mlseek: Allocate",error);				return -1;			}			more_space -= BUFFSIZE;		}		if((error = SetFPos(fd, (short) fsFromStart , absolute_fp )) == noErr)			return absolute_fp;		else			aprintf("failed to seek to %d\n",absolute_fp);	}	ap_error("mlseek",error);	return -1;}	long mlgetpos(	short fd){OSErr			error;long pos;	if((error = GetFPos(fd,&pos)) ==  noErr)		return pos;	ap_error("mlgetpos: GetFPos",error);	return -1;}/*Set a files type and creator*/void settype(	char *filename,	short vRefNum,	char *type,	char *creator){FInfo fndrinfo;short hold;	getfinfo(filename, vRefNum, &fndrinfo);	hold = fndrinfo.fdFlags; /* need to save and restore as strncpy adds a null*/	strncpy((char *)&fndrinfo.fdType,type,4);	strncpy((char *)&fndrinfo.fdCreator, creator, 4);	fndrinfo.fdFlags = hold;	setfinfo(filename, vRefNum, &fndrinfo);}short get_vRefNum(	char * buff ){	return 0;}